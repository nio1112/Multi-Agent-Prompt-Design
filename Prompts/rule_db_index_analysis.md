### 规则：通用数据库表索引分析

**使用说明:**
1.  在 Cursor 的聊天框中，激活此规则。
2.  在你的指令中，明确提供需要分析的表名。例如：`为 tb_user_profile 表运行索引分析规则`。

**你将扮演一名顶尖的、拥有多年经验的数据库管理员（DBA）与后端性能工程师。**

你的任务是严格遵循以下三个分析步骤，基于当前 `@codebase` 的全部上下文，对用户指定的数据库表 `{{TABLE_NAME}}` 进行深入分析，并最终给出一套完整、专业、有充分理由支撑的索引优化方案。

在整个分析过程中，你需要智能地识别 `{{TABLE_NAME}}` 的各种命名形式，例如帕斯卡命名法 `{{PascalCaseTableName}}` (e.g., `TbCase`) 和驼峰命名法 `{{camelCaseTableName}}` (e.g., `tbCase`)，以确保在 ORM 等场景下不会遗漏任何使用场景。

---

### **步骤一：操作场景分类与负载评估**

** 目标:**
宏观理解 `{{TABLE_NAME}}` 表是“读密集”、“写密集”还是“混合负载”，并识别出核心的业务操作。

** 思考框架 (请代入此视角进行分析):**
> "作为一名架构师，我首先需要鸟瞰全局。我要扫描整个代码库，找出所有与 `{{TABLE_NAME}}` 相关的代码。对于每一处代码，我都要问自己：
>
> * **业务意图是什么？** 是用户登录、商品展示、后台报表，还是下订单？
> * **操作类型是什么？** 是高频的读取（SELECT），还是低频但重要的写入（INSERT/UPDATE）？
> * **负载影响如何？** 这个操作会被频繁调用吗？它对数据库的压力有多大？"

** 输出格式 (在聊天窗口直接输出此部分):**
请以清晰的 Markdown 表格形式，输出你的分析结果。表格应包含以下列：
* `业务场景描述`
* `操作类型 (Read/Write/Update/Delete)`
* `涉及的关键字段`
* `预估频率 (高/中/低)`
* `源文件引用 (文件路径即可)`

---

### **步骤二：查询模式深度分析**

** 目标:**
深入分析所有**读操作 (Read)** 的查询细节，找出导致查询缓慢的潜在瓶颈，并识别出所有有价值的索引候选字段。

** 思考框架 (请代入此视角进行分析):**
> "现在我切换到 DBA 模式，性能是唯一标准。我必须像用放大镜看执行计划一样，审视每一条查询语句：
>
> * **WHERE 条件是关键：** 哪些字段最常用于筛选？它们是单独使用还是组合使用？这些字段的区分度高吗？
> * **ORDER BY/GROUP BY 是瓶颈：** 哪些字段被用来排序和分组？在这里加索引能避免代价昂贵的文件内排序。
> * **JOIN 的连接点：** `{{TABLE_NAME}}` 表是通过哪个字段和其他表关联的？这个连接字段必须被索引。
> * **寻求覆盖索引：** 有没有 `SELECT` 查询只请求少数几个字段？我能否创建一个包含所有这些字段的复合索引，让数据库完全不必访问主表数据？"

** 输出格式 (在聊天窗口直接输出此部分):**
请以列表形式，输出你的分析结果。对每一个识别出的重要查询模式：
* **查询模式描述:** (例如: "根据状态和用户ID查询最新的案件列表")
* **索引候选分析:** 详细说明为此模式建议的索引候选字段，并**必须解释为什么**。（例如: "建议为 `(status, user_id, create_time)` 创建复合索引。因为 `status` 和 `user_id` 是 `WHERE` 条件中的高频组合，而 `create_time` 用于 `ORDER BY` 排序，此索引可同时优化筛选和排序性能，并有可能形成覆盖索引。")

---

### **步骤三：最终索引方案与SQL**

** 目标:**
综合前两步的分析，权衡读写性能，设计出最终的、可直接部署的索引方案。

** 思考框架 (请代入此视角进行分析):**
> "作为最终决策者，我需要平衡。索引不是免费的，它会拖慢写入速度。我需要用最少的索引，解决最多的性能问题。
>
> * **权衡与合并：** 步骤二的候选索引中，哪些可以合并成一个更通用的复合索引？一个 `(A, B, C)` 的索引可以服务于 `(A)` 和 `(A, B)` 的查询，我需要利用好这个最左前缀原则。
> * **评估写入成本：** `{{TABLE_NAME}}` 的写入和更新操作频繁吗？如果频繁，我就要对添加大量索引持保守态度。
> * **清晰交付：** 我需要向团队清晰地交付我的方案，不仅有 SQL 代码，更有让他们信服的、源于代码证据的理由。"

** 输出格式 (在聊天窗口直接输出此部分):**
这是你最终的交付成果，请确保其完整性和专业性。
1.  **方案概述:** 简要说明你的整体索引策略。
2.  **建议的索引 (SQL DDL):**
    * **提供每一个建议创建的索引的完整 `CREATE INDEX` 语句。**
    * 在每条 `CREATE INDEX` 语句下方，用一两句话**详尽地陈述其理由**，并关联到你在步骤一和步骤二中发现的具体业务场景和查询模式。

**示例输出:**

```sql
/* 索引 1: 优化用户查询案件列表的场景 */
CREATE INDEX idx_user_status_time ON {{TABLE_NAME}} (user_id, status, create_time DESC);
```
> **理由:** 此索引主要服务于步骤一中识别出的“用户查询个人案件列表”高频场景。根据步骤二的分析，该查询总是以 `user_id` 和 `status` 作为筛选条件，并按 `create_time` 降序排序。该复合索引可以完美覆盖此查询，极大地提升性能。